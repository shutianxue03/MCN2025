% Simulate data for PCA, PPCA and factor analysis

% Generated by Copilot
% Not examined yet


clear all; close all; clc;
randn('state',0); rand('state',0);


N = 1000; % # of data points
D = 10;   % # of neurons/dimensions
M = 3;    % # of latent dimensions
W = randn(D,M); % loading matrix
z = randn(N,M); % latent variables

% generate data
x = z*W' + 0.1*randn(N,D);

% center data
x = x - repmat(mean(x),N,1);

% compute sample covariance
S = cov(x); 

% compute PCA solution
[U,L,V] = svd(S);

% plot eigenvalues
figure;
semilogy(diag(L),'ko-','LineWidth',2);
xlabel('Index'); ylabel('Eigenvalue');
title('Eigenvalues of Sample Covariance');
% plot first 3 principal directions
figure;
for i=1:3
    subplot(1,3,i);
    plot(W(:,i),'ro-','LineWidth',2); hold on;
    plot(U(:,i),'bs-','LineWidth',2);
    legend('True','PCA');
    title(['Principal Direction #' num2str(i)]);
end

%% compute PPCA solution
sigma2 = (trace(S) - sum(diag(L(1:M,1:M))))/(D-M)/D;
Wpca = U(:,1:M)*sqrt(L(1:M,1:M) - sigma2*eye(M));
% plot first 3 principal directions
figure;
for i=1:3
    subplot(1,3,i);
    plot(W(:,i),'ro-','LineWidth',2); hold on;      
    plot(Wpca(:,i),'bs-','LineWidth',2);
    legend('True','PPCA');
    title(['Principal Direction #' num2str(i)]);
end
% compute factor analysis solution using EM algorithm
% initialize parameters
Wfa = randn(D,M);
psi = 0.1*eye(D);
maxIter = 100;
for iter=1:maxIter
    % E-step
    Mfa = inv(eye(M) + Wfa'*inv(psi)*Wfa);
    Ez = (x*inv(psi)*Wfa)*Mfa; % N x M
    Ezz = sigma2*Mfa + Ez'*Ez/N; % M x M
    % M-step
    Wfa = (x'*Ez)/Ezz; % D x M
    psi = diag(diag(cov(x) - Wfa*(Ez'*x)/N)); % D x D
end

% plot first 3 principal directions
figure;
for i=1:3
    subplot(1,3,i);
    plot(W(:,i),'ro-','LineWidth',2); hold on;      
    plot(Wfa(:,i),'bs-','LineWidth',2);
    legend('True','Factor Analysis');
    title(['Principal Direction #' num2str(i)]);
end 



%% Simulate Gaussian process data
% Gaussian Process Simulation in MATLAB
rng(42); % for reproducibility

% Define input points
x = linspace(-5, 5, 100)';  % column vector (100 x 1)
n = length(x);

% Define RBF (Gaussian) kernel function
rbf_kernel = @(x1, x2, l, sigma_f) sigma_f^2 * exp(-0.5 * pdist2(x1, x2).^2 / l^2);

% Set kernel parameters
lengthscale = 1.0;     % controls smoothness
sigma_f = 1.0;         % kernel amplitude
sigma_n = 1e-6;        % small noise for numerical stability

% Compute the kernel matrix (covariance matrix)
K = rbf_kernel(x, x, lengthscale, sigma_f) + sigma_n * eye(n);

% Draw samples from the GP prior
num_samples = 5;
L = chol(K, 'lower');                     % Cholesky decomposition
f_samples = L * randn(n, num_samples);    % Sample from N(0, K)

% Plot the samples
figure;
plot(x, f_samples, 'LineWidth', 1.5);
xlabel('Input x');
ylabel('Function value f(x)');
title('Samples from a Gaussian Process Prior');
legend(arrayfun(@(i) sprintf('Sample %d', i), 1:num_samples, 'UniformOutput', false));
grid on;